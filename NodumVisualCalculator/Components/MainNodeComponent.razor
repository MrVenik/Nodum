@if (_currentMainNode != null)
{
    <div class="main-node" @onmousemove="DrawMainLine" @ondblclick="StopDrawingMainLine">
        <div class="main-node-header">
            <div class="main-node-header-element">
                <span class="iconify iconify-main" data-icon="mdi:menu" data-inline="false"></span>
            </div>
            <div class="main-node-header-element main-node-header-text">@_currentMainNode.Name</div>
            @if (CloseButtonShowed)
            {
                <div class="main-node-header-element" @onclick="() => OnCloseButtonClicked?.Invoke()">
                    <span class="iconify iconify-main" data-icon="mdi:close" data-inline="false"></span>
                </div>
            }
        </div>

        @foreach (var line in _allLines)
        {
            <svg x="0" y="0" width="100%" height="100%" style="position: absolute; top: 0; left: 0; z-index: 0;">
                <defs>
                    <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color: green; stop-opacity: 1" />
                        <stop offset="100%" style="stop-color: red; stop-opacity: 1" />
                    </linearGradient>
                </defs>
                <path fill="none" stroke="url(#grad1)" stroke-width="8" d="@line.Curve" />
            </svg>
        }

        <svg x="0" y="0" width="100%" height="100%" style="position: absolute; top: 0; left: 0; z-index: 0;">
            <defs>
                <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color: green; stop-opacity: 1" />
                    <stop offset="100%" style="stop-color: red; stop-opacity: 1" />
                </linearGradient>
            </defs>
            <path fill="none" stroke="url(#grad1)" stroke-width="3" d="@_mainLine.Curve" />
        </svg>

        <DraggableZone Height="100%" Width="100%">
            @foreach (var visualNode in _currentMainNode.VisualNodes)
            {
                <DraggableWindow @key="visualNode" X="@visualNode.Position.X" Y="@visualNode.Position.Y" AllowDrag="true" OnDragingWindow="@((e, w) => OnNodeDragging(e, w, visualNode))">
                    <WindowHeader>
                        <div class="node-window-header">
                            <div class="node-window-header-element">
                                <span class="iconify iconify-small" data-icon="mdi:menu" data-inline="false"></span>
                            </div>
                            <div class="node-window-header-element node-window-header-text">@visualNode.Name (@visualNode.Position.X, @visualNode.Position.Y)</div>
                            <div class="node-window-header-element" @onclick="@(() => CloseWindow(visualNode))">
                                <span class="iconify iconify-small" data-icon="mdi:close" data-inline="false"></span>
                            </div>
                        </div>
                    </WindowHeader>
                    <WindowContent>
                        <div class="node-window">
                            <NodeComponent VisualNode="@visualNode" OnNodePinSelect="@((a, n) => OnNodeSelect(a, n))" OnNodePinConnect="@((a, n, i) => OnNodeConnect(a, n, i))" />
                        </div>
                    </WindowContent>
                </DraggableWindow>
            }
        </DraggableZone>
    </div>
}

@code {
    [Parameter]
    public VisualNodeHolder MainNode { get; set; }
    [Parameter]
    public bool CloseButtonShowed { get; set; }
    [Parameter]
    public Action OnCloseButtonClicked { get; set; }

    private bool _isEditor = false;

    private VisualNodeHolder _currentMainNode;

    private VisualNode _selectedNode;

    private List<Line> _allLines = new List<Line>();

    private Line _mainLine = new Line();
    private bool _isMainLineDrawing = false;

    protected override void OnInitialized()
    {
        _currentMainNode = MainNode;
        CreateNewAddNode();
        CreateNewNumberNode();
    }

    private void OnNodeSelect(MouseEventArgs args, VisualNode visualNode)
    {
        _mainLine.From = new Position() { X = args.ClientX, Y = args.ClientY };

        _isMainLineDrawing = true;

        if (visualNode.Node is IOutputNode)
        {
            _selectedNode = visualNode;
        }
    }

    private void DrawMainLine(MouseEventArgs args)
    {
        if (_isMainLineDrawing)
        {
            _mainLine.To = new Position() { X = args.ClientX, Y = args.ClientY };
        }
    }

    private void StopDrawingMainLine(MouseEventArgs args)
    {
        if (_isMainLineDrawing)
        {
            _isMainLineDrawing = false;
            _mainLine = new Line();
        }
    }

    private void OnNodeConnect(MouseEventArgs args, VisualNode inputNode, int index)
    {
        StopDrawingMainLine(args);

        if (inputNode.Node is ISingleInputNode singleInputNode)
        {
            singleInputNode.AddIncomingNode(_selectedNode.Node as IOutputNode);
            inputNode.Lines.Add(new Line() { From = _selectedNode.OutputNodePin.Position, To = inputNode.InputNodePins[0].Position });
        }
        else if (inputNode.Node is ICommutateInputNode commutateInputNode)
        {
            commutateInputNode.AddIncomingNode(_selectedNode.Node as IOutputNode);
            inputNode.Lines.Add(new Line() { From = _selectedNode.OutputNodePin.Position, To = inputNode.InputNodePins[0].Position });
        }
        else if (inputNode.Node is IMultipleInputNode multipleInputNode)
        {
            multipleInputNode.AddIncomingNode(_selectedNode.Node as IOutputNode, index);
            inputNode.Lines.Add(new Line() { From = _selectedNode.OutputNodePin.Position, To = inputNode.InputNodePins[index].Position });
        }

        UpdateLines();
    }

    private void UpdateLines()
    {
        _currentMainNode.Position.OnPositionChanged?.Invoke();
        _allLines.Clear();
        foreach (var vn in _currentMainNode.VisualNodes)
        {
            if (vn is VisualNode visualNode)
            {
                _allLines.AddRange(visualNode.Lines);
            }
        }

        StateHasChanged();
    }

    private void CreateNewNodeHolder()
    {
        _currentMainNode.AddNode(new VisualNodeHolder("New Node Holder", _currentMainNode));
    }

    private void CreateNewNumberNode()
    {
        _currentMainNode.AddNode(new VisualNode(new InputDoubleNode("Number"), _currentMainNode));
    }

    private void CreateNewAddNode()
    {
        _currentMainNode.AddNode(new VisualNode(new DoubleAddFuncNode("Add"), _currentMainNode));
    }

    private void CloseWindow(IVisualNode window)
    {
        _currentMainNode.RemoveNode(window);

        UpdateLines();
    }

    private void OnNodeStartDragging(MouseEventArgs args, DraggableWindow nodeWindow, INode node)
    {

    }

    private void OnNodeDragging(MouseEventArgs args, DraggableWindow nodeWindow, IVisualNode node)
    {
        node.Position.X = nodeWindow.Offset.Left;
        node.Position.Y = nodeWindow.Offset.Top;

        UpdateLines();
    }
}
