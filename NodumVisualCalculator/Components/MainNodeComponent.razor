@inject IJSRuntime JSRuntime

<NodeCreatorComponent @ref="_nodeCreator" />
<NodeEditorComponent @ref="_nodeEditor" />
<NodePinCreatorComponent @ref="_nodePinCreator" />

@if (_currentMainNode != null)
{
    <div class="main-node" @onmousemove="DrawMainLine" @ondblclick="StopDrawingMainLine">
        <div class="main-node-header">
            <Dropdown>
                <DropdownTrigger>
                    <div class="main-node-header-element">
                        <span class="iconify iconify-main" data-icon="mdi:menu" data-inline="false"></span>
                    </div>
                </DropdownTrigger>
                <DropdownContent>
                    <DropdownElement HideOnClick="true" OnClick="@((e) => _mainSidebar.OpenOrClose())">
                        Open Nodes List
                    </DropdownElement>
                    <DropdownElement HideOnClick="true" OnClick="@((e) => _nodeEditor.Open(_currentMainNode))">
                        Edit Node
                    </DropdownElement>
                    <DropdownElement HideOnClick="true" OnClick="@((e) => Save())">
                        Save Node
                    </DropdownElement>
                    @if (_isEditor)
                    {
                        <DropdownElement HideOnClick="true" OnClick="@((e) => _nodePinCreator.Open(_currentMainNode))">
                            Add New NodePin
                        </DropdownElement>
                    }
                </DropdownContent>
            </Dropdown>

            <div class="main-node-header-element" style="display: @(_currentMainNode == MainNode ? "none" : "block")" @onclick="() => EditNode(_currentMainNode.Holder)">
                <span class="iconify iconify-main" data-icon="mdi:arrow-left" data-inline="false"></span>
            </div>
            <div class="main-node-header-element main-node-header-text">@_currentMainNode.Name</div>
            @if (CloseButtonShowed)
            {
                <div class="main-node-header-element" @onclick="() => OnCloseButtonClicked?.Invoke()">
                    <span class="iconify iconify-main" data-icon="mdi:close" data-inline="false"></span>
                </div>
            }
        </div>

        <div class="main-node-body">

            <Sidebar @ref="_mainSidebar">
                @foreach (var group in NodeCacher.AllBaseNodes)
                {
                    <SidebarTab>
                        <SidebarTabHeader>
                            @group.Key
                        </SidebarTabHeader>
                        <SidebarTabElements>
                            @foreach (var node in group.Value)
                            {
                                <SidebarTabElement OnClick="@((e) => _nodeCreator.Open(_currentMainNode, node.Clone()))">
                                    Add @node.Name
                                </SidebarTabElement>
                            }
                        </SidebarTabElements>
                    </SidebarTab>

                }
            </Sidebar>

            @foreach (var connection in _allConnections)
            {
                <svg x="0" y="0" width="100%" height="100%" style="position: absolute; top: 0; left: 0; z-index: 0;">
                    <defs>
                        <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" style="stop-color: green; stop-opacity: 1" />
                            <stop offset="100%" style="stop-color: red; stop-opacity: 1" />
                        </linearGradient>
                    </defs>
                    <path id="@($"{connection.FromPin.OutputElementId}+{connection.ToPin.InputElementId}")" class="node-line" fill="none" stroke="url(#grad1)" stroke-width="8" d="M 0, 0" />
                </svg>
            }

            <svg id="main-node-line" x="0" y="0" width="100%" height="100%" style="position: absolute; top: 0; left: 0; z-index: 0;">
                <defs>
                    <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color: green; stop-opacity: 1" />
                        <stop offset="100%" style="stop-color: red; stop-opacity: 1" />
                    </linearGradient>
                </defs>
                <path fill="none" stroke="url(#grad1)" stroke-width="3" d="@_mainLine.Curve" />
            </svg>

            <DraggableZone Height="100%" Width="100%">
                @foreach (var visualNode in _currentMainNode.InternalVisualNodes)
                {
                    <DraggableWindow @key="visualNode" X="@visualNode.Position.X" Y="@visualNode.Position.Y" AllowDrag="true" OnDragingWindow="@((w) => OnNodeDragging(w, visualNode))">
                        <WindowHeader>
                            <div class="node-window-header">

                                <Dropdown>
                                    <DropdownTrigger>
                                        <div class="node-window-header-element">
                                            <span class="iconify iconify-small" data-icon="mdi:menu" data-inline="false"></span>
                                        </div>
                                    </DropdownTrigger>
                                    <DropdownContent>
                                        @if (visualNode.Node.IsEditable)
                                        {
                                            <DropdownElement HideOnClick="true" OnClick="@((e) => EditNode(visualNode))">
                                                Edit Node
                                            </DropdownElement>
                                        }
                                        else
                                        {
                                            <DropdownElement HideOnClick="true" OnClick="@((e) => _nodeEditor.Open(visualNode))">
                                                Edit Node
                                            </DropdownElement>
                                        }
                                    </DropdownContent>
                                </Dropdown>

                                <div class="node-window-header-element node-window-header-text">@visualNode.Name (@visualNode.Position.X, @visualNode.Position.Y)</div>
                                <div class="node-window-header-element" @onclick="@(() => CloseWindow(visualNode))">
                                    <span class="iconify iconify-small" data-icon="mdi:close" data-inline="false"></span>
                                </div>
                            </div>
                        </WindowHeader>
                        <WindowContent>
                            <div class="node-window">
                                <NodeComponent VisualNode="@visualNode" OnNodePinSelect="@((a, n) => OnNodePinSelect(a, n))" OnNodePinConnect="@((a, n) => OnNodePinConnect(a, n))" />
                            </div>
                        </WindowContent>
                    </DraggableWindow>
                }
            </DraggableZone>

        </div>
    </div>
}

@code {
    [Parameter]
    public VisualNode MainNode { get; set; }
    [Parameter]
    public bool CloseButtonShowed { get; set; }
    [Parameter]
    public Action OnCloseButtonClicked { get; set; }

    private bool _isEditor = false;

    private VisualNode _currentMainNode;

    private VisualNodePin _selectedNodePin;

    private Sidebar _mainSidebar;

    private NodeCreatorComponent _nodeCreator;
    private NodeEditorComponent _nodeEditor;
    private NodePinCreatorComponent _nodePinCreator;

    private List<NodePinConnection> _allConnections = new List<NodePinConnection>();

    private Line _mainLine = new Line();
    private bool _isMainLineDrawing = false;

    protected override void OnInitialized()
    {
        _currentMainNode = MainNode;
    }

    private void Save()
    {
        BinaryNodeSerializer nodeSerializer = new BinaryNodeSerializer();
        nodeSerializer.Serialize(_currentMainNode.Node);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        //TODO: Create normal method to update lines when something changes
        //await UpdateLines();
    }

    private void OnNodePinSelect(MouseEventArgs args, VisualNodePin visualNodePin)
    {
        _mainLine.From = new Position() { X = args.ClientX, Y = args.ClientY };

        _isMainLineDrawing = true;

        _selectedNodePin = visualNodePin;
    }

    private async void OnNodePinConnect(MouseEventArgs args, VisualNodePin visualNodePin)
    {
        StopDrawingMainLine(args);

        visualNodePin.ConnectToNodePin(_selectedNodePin);

        UpdateConnections();

        await UpdateLines();
    }

    private void DrawMainLine(MouseEventArgs args)
    {
        if (_isMainLineDrawing)
        {
            _mainLine.To = new Position() { X = args.ClientX, Y = args.ClientY };
        }
    }

    private void StopDrawingMainLine(MouseEventArgs args)
    {
        if (_isMainLineDrawing)
        {
            _isMainLineDrawing = false;
            _mainLine = new Line();
        }
    }

    private async Task UpdateLines()
    {
        await JSRuntime.InvokeVoidAsync("nodeLineHandler.UpdateLines");
    }

    private void UpdateConnections()
    {
        _allConnections.Clear();
        foreach (var visualNode in _currentMainNode.InternalVisualNodes)
        {
            _allConnections.AddRange(visualNode.IncomingConnections);
        }

        StateHasChanged();
    }

    private void CreateNewNode(Node node)
    {
        _currentMainNode.AddNode(new VisualNode(node, _currentMainNode));
    }

    private void CloseWindow(VisualNode window)
    {
        _currentMainNode.RemoveNode(window);

        UpdateConnections();
    }

    private async void EditNode(VisualNode nodeHolder)
    {
        if (nodeHolder != null)
        {
            _isEditor = true;
            _currentMainNode = nodeHolder;
        }
        else
        {
            _isEditor = false;
            _currentMainNode = MainNode;
        }

        UpdateConnections();
        await UpdateLines();
    }

    private void OnNodeDragging(DraggableWindow nodeWindow, VisualNode node)
    {
        node.Position.X = nodeWindow.PositionX;
        node.Position.Y = nodeWindow.PositionY;

        UpdateConnections();
    }
}
