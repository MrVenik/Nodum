@inject IJSRuntime JSRuntime

<NodeCreatorComponent @ref="_nodeCreator" />
<NodeEditorComponent @ref="_nodeEditor" />

@if (_currentMainNode != null)
{
    <div class="main-node" @onmousemove="DrawMainLine" @ondblclick="StopDrawingMainLine">
        <div class="main-node-header">
            <Dropdown>
                <DropdownTrigger>
                    <div class="main-node-header-element">
                        <span class="iconify iconify-main" data-icon="mdi:menu" data-inline="false"></span>
                    </div>
                </DropdownTrigger>
                <DropdownContent>
                    <DropdownElement HideOnClick="true" OnClick="@((e) => _nodeEditor.Open(_currentMainNode))">
                        Edit Node
                    </DropdownElement>
                    <DropdownElement HideOnClick="true" OnClick="@((e) => _nodeCreator.Open(_currentMainNode))">
                        Add Empty Node
                    </DropdownElement>
                    <DropdownElement HideOnClick="true" OnClick="@((e) => CreateNewNode(new MathNode() { Name = "Math Node"}))">
                        Add Math Node
                    </DropdownElement>
                    <DropdownElement HideOnClick="true" OnClick="@((e) => CreateNewNode(new NumberNode() { Name = "Number Node"}))">
                        Add Number Node
                    </DropdownElement>
                    <DropdownElement HideOnClick="true" OnClick="@((e) => CreateNewNode(new RegexMathNode() { Name = "Regex Math Node"}))">
                        Add Regex Math Node
                    </DropdownElement>
                </DropdownContent>
            </Dropdown>

            <div class="main-node-header-element" style="display: @(_currentMainNode == MainNode ? "none" : "block")" @onclick="() => { _currentMainNode = _currentMainNode.Holder ?? MainNode; UpdateConnections(); }">
                <span class="iconify iconify-main" data-icon="mdi:arrow-left" data-inline="false"></span>
            </div>
            <div class="main-node-header-element main-node-header-text">@_currentMainNode.Name</div>
            @if (CloseButtonShowed)
            {
                <div class="main-node-header-element" @onclick="() => OnCloseButtonClicked?.Invoke()">
                    <span class="iconify iconify-main" data-icon="mdi:close" data-inline="false"></span>
                </div>
            }
        </div>

        @foreach (var connection in _allConnections)
        {
            <svg x="0" y="0" width="100%" height="100%" style="position: absolute; top: 0; left: 0; z-index: 0;">
                <defs>
                    <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color: green; stop-opacity: 1" />
                        <stop offset="100%" style="stop-color: red; stop-opacity: 1" />
                    </linearGradient>
                </defs>
                <path id="@($"{connection.FromPin.OutputElementId}+{connection.ToPin.InputElementId}")" class="node-line" fill="none" stroke="url(#grad1)" stroke-width="8" d="M 0, 0" />
            </svg>
        }

        <svg id="main-node-line" x="0" y="0" width="100%" height="100%" style="position: absolute; top: 0; left: 0; z-index: 0;">
            <defs>
                <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color: green; stop-opacity: 1" />
                    <stop offset="100%" style="stop-color: red; stop-opacity: 1" />
                </linearGradient>
            </defs>
            <path fill="none" stroke="url(#grad1)" stroke-width="3" d="@_mainLine.Curve" />
        </svg>

        <DraggableZone Height="100%" Width="100%">
            @foreach (var visualNode in _currentMainNode.InternalVisualNodes)
            {
                <DraggableWindow @key="visualNode" X="@visualNode.Position.X" Y="@visualNode.Position.Y" AllowDrag="true" OnDragingWindow="@((w) => OnNodeDragging(w, visualNode))">
                    <WindowHeader>
                        <div class="node-window-header">
                            @if (visualNode.Editable)
                            {
                                <Dropdown>
                                    <DropdownTrigger>
                                        <div class="node-window-header-element">
                                            <span class="iconify iconify-small" data-icon="mdi:menu" data-inline="false"></span>
                                        </div>
                                    </DropdownTrigger>
                                    <DropdownContent>
                                        <DropdownElement HideOnClick="true" OnClick="@((e) => EditNode(visualNode))">
                                            Edit Node
                                        </DropdownElement>
                                        <DropdownElement HideOnClick="true" OnClick="@((e) => visualNode.AddInputNodePin(typeof(double)))">
                                            Add Input
                                        </DropdownElement>
                                        <DropdownElement HideOnClick="true" OnClick="@((e) => visualNode.AddOutputNodePin(typeof(double)))">
                                            Add Output
                                        </DropdownElement>
                                    </DropdownContent>
                                </Dropdown>
                            }
                            <div class="node-window-header-element node-window-header-text">@visualNode.Name (@visualNode.Position.X, @visualNode.Position.Y)</div>
                            <div class="node-window-header-element" @onclick="@(() => CloseWindow(visualNode))">
                                <span class="iconify iconify-small" data-icon="mdi:close" data-inline="false"></span>
                            </div>
                        </div>
                    </WindowHeader>
                    <WindowContent>
                        <div class="node-window">
                            <NodeComponent VisualNode="@visualNode" OnNodePinSelect="@((a, n) => OnNodePinSelect(a, n))" OnNodePinConnect="@((a, n) => OnNodePinConnect(a, n))" />
                        </div>
                    </WindowContent>
                </DraggableWindow>
            }
        </DraggableZone>
    </div>
}

@code {
    [Parameter]
    public VisualNode MainNode { get; set; }
    [Parameter]
    public bool CloseButtonShowed { get; set; }
    [Parameter]
    public Action OnCloseButtonClicked { get; set; }

    private bool _isEditor = false;

    private VisualNode _currentMainNode;

    private VisualNodePin _selectedNodePin;

    private NodeCreatorComponent _nodeCreator;
    private NodeEditorComponent _nodeEditor;

    private List<NodePinConnection> _allConnections = new List<NodePinConnection>();

    private Line _mainLine = new Line();
    private bool _isMainLineDrawing = false;

    protected override void OnInitialized()
    {
        _currentMainNode = MainNode;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        //TODO: Create normal method to update lines when something changes
        //await UpdateLines();
    }

    private void OnNodePinSelect(MouseEventArgs args, VisualNodePin visualNodePin)
    {
        _mainLine.From = new Position() { X = args.ClientX, Y = args.ClientY };

        _isMainLineDrawing = true;

        _selectedNodePin = visualNodePin;
    }

    private async void OnNodePinConnect(MouseEventArgs args, VisualNodePin visualNodePin)
    {
        StopDrawingMainLine(args);

        visualNodePin.ConnectToNodePin(_selectedNodePin);

        UpdateConnections();

        await UpdateLines();
    }

    private void DrawMainLine(MouseEventArgs args)
    {
        if (_isMainLineDrawing)
        {
            _mainLine.To = new Position() { X = args.ClientX, Y = args.ClientY };
        }
    }

    private void StopDrawingMainLine(MouseEventArgs args)
    {
        if (_isMainLineDrawing)
        {
            _isMainLineDrawing = false;
            _mainLine = new Line();
        }
    }

    private async Task UpdateLines()
    {
        await JSRuntime.InvokeVoidAsync("nodeLineHandler.UpdateLines");
    }

    private void UpdateConnections()
    {
        _allConnections.Clear();
        foreach (var visualNode in _currentMainNode.InternalVisualNodes)
        {
            _allConnections.AddRange(visualNode.IncomingConnections);
        }

        StateHasChanged();
    }

    private void CreateNewNode(Node node)
    {
        _currentMainNode.AddNode(new VisualNode(node, _currentMainNode));
    }

    private void CloseWindow(VisualNode window)
    {
        _currentMainNode.RemoveNode(window);

        UpdateConnections();
    }

    private async void EditNode(VisualNode nodeHolder)
    {
        nodeHolder.MenuShowed = false;
        _isEditor = true;
        _currentMainNode = nodeHolder;
        UpdateConnections();
        await UpdateLines();
    }

    private void OnNodeDragging(DraggableWindow nodeWindow, VisualNode node)
    {
        node.Position.X = nodeWindow.PositionX;
        node.Position.Y = nodeWindow.PositionY;

        UpdateConnections();
    }
}
